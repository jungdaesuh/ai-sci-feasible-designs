Role: You are the GOAT in physics, math, computation, AI/ML, statistics, stellarator, nuclear fusion, and a practical senior software engineer.

DO NOT MODIFY ORIGINAL CODE IN CONSTELLARATION repo.
DO NOT MODIFY ORIGINAL CODE IN VMECPP repo.

This is the **Unified Master Guideline for the ConStellaration Fusion Challenge**. It integrates the theoretical physics context, data schema, and execution protocols with the specific numerical benchmarks and baseline targets required to solve the challenge. It is designed to be ingested by an autonomous coding agent.

-----

# ðŸŒŒ ConStellaration Fusion Challenge: Unified Master Guideline

## 1\. Executive Summary

  * [cite\_start]**Goal:** Design optimized plasma boundary shapes for a "stellarator" fusion reactor using Machine Learning[cite: 1].
  * **Why:** Stellarators are the safest path to continuous fusion energy, but their design space is high-dimensional and computationally expensive. [cite\_start]We need ML to accelerate the optimization of these complex 3D shapes[cite: 1].
  * [cite\_start]**Host:** Proxima Fusion & Hugging Face[cite: 1].
  * [cite\_start]**Dataset:** `proxima-fusion/constellaration` containing \~158,000 Quasi-Isodynamic (QI) equilibria with computed MHD metrics[cite: 2].
  * [cite\_start]**Core Task:** Optimize Fourier coefficients ($R_{mn}, Z_{mn}$) of the plasma boundary to satisfy specific physics objectives (confinement, stability, buildability)[cite: 1].
  * [cite\_start]**Winning Condition:** Beat the strong baselines established by `ALM-NGOpt` (Augmented Lagrangian Method with Gradient-Free Optimization)[cite: 1].

-----

## 2\. Theoretical Context (Physics for Agents)

### 2.1 The Machine: Stellarator

  * [cite\_start]**What it is:** A fusion device that confines hot plasma using twisted 3D magnetic fields generated by external coils[cite: 1].
  * **Key Difference:** Unlike Tokamaks (symmetric donuts), Stellarators are twisted and non-symmetric. [cite\_start]This makes them steady-state (always on) but significantly harder to design[cite: 1].
  * **Target State (QI):** **Quasi-Isodynamic (QI)**. [cite\_start]This is a special property where, despite the 3D twist, particles stay confined (omnigenous) and don't drift away[cite: 1].
  * **VMEC++ (The Oracle):** The physics simulator used for ground-truth evaluation. [cite\_start]It takes a boundary shape as input and calculates the vacuum ideal-MHD equilibrium to verify if it holds plasma effectively[cite: 1].

### 2.2 The Input: Plasma Boundary ($S$)

[cite\_start]The plasma boundary is a closed 2D surface in 3D space, defined by a **Truncated Fourier Series** in cylindrical coordinates $(R, \phi, Z)$[cite: 1].

  * **$R(\theta, \phi)$**: Radial distance from the main axis.
  * **$Z(\theta, \phi)$**: Vertical height.
  * **$\phi$**: Toroidal angle (long way around the donut).
  * **$\theta$**: Poloidal angle (short way around the donut cross-section).

**Mathematical Representation:**
$$R(\theta, \phi) = \sum_{m,n} R_{mn} \cos(m\theta - nN_{fp}\phi)$$
$$Z(\theta, \phi) = \sum_{m,n} Z_{mn} \sin(m\theta - nN_{fp}\phi)$$

  * **Decision Variables:** The coefficients $R_{mn}$ and $Z_{mn}$.
  * [cite\_start]**Symmetry:** We assume "Stellarator Symmetry" ($R$ is even in phases, $Z$ is odd)[cite: 1].
  * [cite\_start]**$N_{fp}$:** Number of field periods (standard for benchmarks is 3)[cite: 1].

### 2.3 Critical Metric Definitions

  * **Aspect Ratio ($A$):** Major radius / Minor radius. [cite\_start]Lower = More compact (Better economics, harder physics)[cite: 1].
  * **Max Elongation ($\epsilon_{max}$):** Stretching of the plasma cross-section. [cite\_start]Lower = Simpler geometry[cite: 1].
  * **Magnetic Gradient Scale Length ($L_{\nabla B}$):** A proxy for **Coil Simplicity**.
      * **Rule:** **Higher is Better** ($\uparrow$). [cite\_start]Larger scale length implies smoother fields, which allow for easier-to-build coils[cite: 1].
  * **Vacuum Well ($W_{MHD}$):** Stability metric. [cite\_start]**Must be $\ge 0$** for stability[cite: 1].
  * **QI Residual:** Deviation from perfect Quasi-Isodynamicity. [cite\_start]Lower is better[cite: 1].

-----

## 3\. The Data: `proxima-fusion/constellaration`

  * [cite\_start]**Dataset Location:** Hugging Face Dataset[cite: 2].
  * [cite\_start]**Size:** \~158,000 valid samples[cite: 1].
  * **Schema:**
      * `boundary.json`: The input. [cite\_start]Contains `r_cos` ($R_{mn}$) and `z_sin` ($Z_{mn}$) matrices[cite: 2].
      * `metrics`: The output labels (calculated by VMEC++).
          * `qi`: Quasi-Isodynamic residual (Lower is better).
          * `aspect_ratio`: Compactness.
          * `max_elongation`: Geometric complexity.
          * `flux_compression_in_regions_of_bad_curvature`: Coil complexity proxy.
          * [cite\_start]`vacuum_well`: Stability metric ($W_{MHD}$)[cite: 2].

-----

## 4\. The Three Problems (The Mission)

You must solve three specific optimization benchmarks of increasing complexity. Use the **Baseline Targets** as your minimum viable product (MVP).

### ðŸ£ Problem 1: Geometrically Optimized Stellarator

  * [cite\_start]**Goal:** Minimize geometric complexity (Elongation) while meeting basic shape constraints[cite: 1].
  * [cite\_start]**Objective:** **Minimize $\epsilon_{max}$** (Max Elongation)[cite: 1].
  * **Constraints:**
      * Aspect Ratio ($A$) $\le A^*$
      * Average Triangularity ($\bar{\delta}$) $\le \bar{\delta}^*$
      * [cite\_start]Edge Rotational Transform ($\iota$) $\ge \iota^*$[cite: 1].
  * **Baseline to Beat (ALM-NGOpt):**
      * [cite\_start]**$\epsilon_{max}$ Score:** **2.10**[cite: 1].
      * *Note:* Simple gradient-based methods (e.g., SciPy) failed this task (Score \> 15.0). [cite\_start]You likely need global optimization or a good surrogate[cite: 1].

### ðŸ—ï¸ Problem 2: Simple-to-Build QI Stellarator

  * [cite\_start]**Goal:** Design a reactor that works (Good Confinement) and is easy to build (Simple Coils)[cite: 1].
  * [cite\_start]**Objective:** **Maximize $L_{\nabla B}$** (Magnetic Gradient Scale Length, the Coil Complexity Proxy)[cite: 1].
  * **Constraints:**
      * [cite\_start]**QI Property:** `qi_residual` $\le$ Strict Threshold[cite: 1].
      * [cite\_start]**Stability:** $W_{MHD} \ge 0$ (Vacuum well must be non-negative)[cite: 1].
      * [cite\_start]**Geometry:** Constraints on Aspect Ratio and Elongation[cite: 1].
  * **Baseline to Beat (ALM-NGOpt):**
      * [cite\_start]**$L_{\nabla B}$ Score:** **8.61**[cite: 1].
      * *Difficulty:* High. Most optimizers fail to find a feasible region where $QI$ is good AND coils are simple.

### ðŸ¦„ Problem 3: Multi-Objective, MHD-Stable QI Stellarator

  * [cite\_start]**Goal:** Find the Pareto Front (Trade-off) between Compactness and Simplicity[cite: 1].
  * **Objectives (Multi-Objective):**
    1.  [cite\_start]**Minimize Aspect Ratio ($A$)** (Make it compact/small)[cite: 1].
    2.  [cite\_start]**Maximize $L_{\nabla B}$** (Make it simple to build)[cite: 1].
  * **Hard Constraints (The "Killer" Constraints):**
      * [cite\_start]**MHD Stability:** $W_{MHD} \ge 0$ (The plasma must be stable against magnetic perturbations)[cite: 1].
      * [cite\_start]**Turbulence:** Flux compression $\le$ Target[cite: 1].
      * [cite\_start]**Confinement:** High QI performance[cite: 1].
  * **Reference Pareto Front (Targets):**
    [cite\_start]Your agent should aim to generate solutions near or better than these pairs[cite: 1]:
      * **Compact:** $A \approx 6.0$, $L_{\nabla B} \approx 3.0$
      * **Balanced:** $A \approx 8.0$, $L_{\nabla B} \approx 5.6$
      * **Simple:** $A \approx 10.0$, $L_{\nabla B} \approx 8.5$
      * **Very Simple:** $A \approx 12.0$, $L_{\nabla B} \approx 11.1$

-----

## 5\. Agent Protocol: Strategy & Execution

### Step 1: Environment Setup

You are likely running in a Python environment. You need the physics codes.

```bash
# Clone the official repo for benchmarks and baselines
git clone https://github.com/proximafusion/constellaration.git
cd constellaration
pip install .

# Install VMEC++ (The Oracle) - Critical for evaluation
# Note: This often requires compiling C++/Fortran code. 
# If pre-built wheels aren't available, look for the Docker container provided by Proxima.
```

### Step 2: The "Cold Start" Strategy

  * **Observation:** Randomly sampling coefficients yields valid stellarators \~0% of the time.
  * [cite\_start]**Tactic:** Do **not** start from random noise[cite: 1].
  * [cite\_start]**Action:** Seed your optimization with the **"Rotating Ellipse"** configuration or the best samples from the dataset[cite: 1].

### Step 3: Surrogate Modeling & Optimization

  * **Observation:** VMEC++ takes minutes/hours. You need seconds.
  * [cite\_start]**Tactic:** Train a **Random Forest** or **MLP** classifier to predict "Feasibility" (Will VMEC++ crash?) and a Regressor for $QI$ and $L_{\nabla B}$[cite: 1].
  * [cite\_start]**Dimensionality Reduction:** Use PCA to reduce the 80-dimensional input space to \~20 dims for faster surrogate training[cite: 1].
  * [cite\_start]**Threshold:** Only send candidates to VMEC++ if your classifier predicts \>80% probability of feasibility[cite: 1].
  * [cite\_start]**Recommended Algorithm:** **ALM-NGOpt** (Augmented Lagrangian with Nevergrad) was the only baseline method that consistently found valid solutions[cite: 1].

### Step 4: Submission Format

Prepare your solution as a JSON file.

```json
{
  "r_cos": [[0, ...], ...],  // 2D Matrix of coefficients
  "z_sin": [[0, ...], ...],  // 2D Matrix of coefficients
  "n_field_periods": 3,      // Standard for benchmarks
  "n_periodicity": 1,
  "is_stellarator_symmetric": true
}
```

### Step 5: Self-Evaluation Checklist

Before submitting, check your constraints:

  * [ ] Is $R_{00}$ (Major Radius) normalized? (Usually scaled to 1.0) [cite\_start][cite: 1].
  * [ ] Does the surface self-intersect? (Geometric check).
  * [ ] Is the Aspect Ratio within the requested range?
  * [ ] Does the Fourier spectrum decay? (High frequency coefficients should be near zero for smoothness).

-----

## 6\. Helper Code Snippets

**Loading a Boundary:**

```python
from constellaration.surface import surface_rz_fourier
import json

data = json.loads(boundary_json_string)
surf = surface_rz_fourier.SurfaceRZFourier.model_validate(data)
```

**Loading Data:**

```python
from datasets import load_dataset
ds = load_dataset("proxima-fusion/constellaration", "default")
# Example: Get a starting boundary
row = ds['train'][0]
boundary_coeffs = row['boundary.json'] 
```

## 7\. Immediate Actions for Agent

1.  [cite\_start]**Browse** `https://github.com/proximafusion/constellaration` to get the `benchmark.py` files for exact weights/thresholds[cite: 1].
2.  **Ingest Data:** Load `proxima-fusion/constellaration` and filter for `vmecpp_wout` (valid runs).
3.  **Train Surrogate:** Build a model to predict $L_{\nabla B}$ and $W_{MHD}$.
4.  **Execute Benchmark 1:** Minimize $\epsilon_{max}$ starting from a valid boundary. Stop when $\epsilon_{max} < 2.1$.
5.  **Execute Benchmark 2:** Maximize $L_{\nabla B}$ while monitoring $QI$. Stop when $L_{\nabla B} > 8.6$.

# Repository Guidelines

## Project Structure & Module Organization
- Python package lives in `constellaration/src/constellaration/` with domains: `geometry/`, `mhd/`, `omnigeneity/`, `optimization/`; data tooling in `data_generation/` and `boozer/`.
- Tests mirror the package under `constellaration/tests/`.
- Repro/bench scripts in `optimization_examples/`; notebooks in `constellaration/notebooks/`.
- GPU-ready forward model wrapper sits in `vmecpp/`. Repo roots like `docs/`, `scripts/`, `tools/`, `runs/`, and `artifacts/` hold auxiliary assets.

## Build, Test, and Development Commands
- Create env: `python -m venv .venv && source .venv/bin/activate` then `pip install -e constellaration[test,lint]` (requires system `libnetcdf-dev`).
- Run full tests: `hatch run test:pytest` or `pytest constellaration/tests`.
- Focused test slice: `pytest -q constellaration/tests/geometry -k <keyword>`.
- Lint: `hatch run lint:ruff check .`; format: `ruff format`.
- Forward model CLI help: `python -m constellaration.forward_model --help`.
- Optimization demos: `python constellaration/optimization_examples/<script>.py`.

## Coding Style & Naming Conventions
- Python 3.10+; 4-space indent; line length â‰¤88.
- Modules/packages use `snake_case`; classes UpperCamelCase; constants UPPER_SNAKE_CASE.
- Type-annotate public APIs; prefer explicit numpy/jax typing (e.g., `jaxtyping`).
- Keep logic simple (KISS/YAGNI/DRY) and favor functional/immutable patterns; composition over inheritance.

## Testing Guidelines
- Use `pytest`; mirror module names: `test_<feature>.py` with functions `test_<behavior>`.
- Mock expensive VMEC calls; seed stochastic routines for determinism.
- Target â‰¥80% branch coverage (`coverage run -m pytest && coverage report` when auditing).
- Shared fixtures belong in `constellaration/tests/conftest.py`.

## Commit & Pull Request Guidelines
- Commits: imperative, present-tense subjects under ~60 chars (e.g., `Add omnigeneity gradient checks`). Group related changes.
- PRs: describe motivation, list validation steps/commands run, link issues or HF assets, and attach plots/screenshots for notebook-facing updates.
- Keep diffs scoped; prefer extending behavior over rewriting; note dataset artifacts if published externally.

## Security & Configuration Tips
- Do not modify the upstream VMEC wrapper or original code unintentionally; respect single-source data in `vmecpp/` and `artifacts/`.
- Maintain unidirectional data flow and avoid state mutation in new modules; keep configuration in one place (configs/ or pyproject).

## Follow these rules

ðŸŽ¯ Core Principles
â€¢ KISS (Keep It Simple, Stupid): Optimize for clarity over cleverness.
â€¢ YAGNI (You Arenâ€™t Gonna Need It): Donâ€™t build features or abstractions until you need them.
â€¢ DRY (Donâ€™t Repeat Yourself): Reuse components and logic, but donâ€™t over-abstract.
â€¢ Single Responsibility: Each component/module should do one thing well.
â€¢ Composition over Inheritance: Build UIs by combining small components instead of subclassing.
â€¢ SSOT(Single Source of Truth).
â€¢ FUNCTIONAL PROGRAMMING, IMMUTABLE PROGRAMMING.

â¸»

ðŸ—ï¸ Architecture & Structure
â€¢ Component-Based Design: Break UI into small, reusable parts.
â€¢ Atomic Design Mindset: Atoms (buttons) â†’ Molecules (forms) â†’ Organisms (sections) â†’ Pages.
â€¢ Feature-Folder Organization: Group code by feature/domain, not by file type.
â€¢ Unidirectional Data Flow: Data flows down (props), actions flow up (callbacks).
â€¢ Separation of Concerns: Keep business logic out of UI components (hooks or containers).

â¸»

ðŸ› ï¸ Code Practices
â€¢ Immutability: Never mutate state directly; always return new objects/arrays.

â¸»

ðŸš€ Startup-Specific Guidance
â€¢ Speed > Perfection: Get to market quickly; optimize once you have users.
â€¢ Choose Boring Tech: Stick to proven libraries (React Query, React Hook Form, Tailwind).
â€¢ Optimize for Change: Expect pivotsâ€”keep architecture flexible, not rigid.
â€¢ Observability Early: Add error logging (Sentry) and analytics from day one.

â¸»

## Timeless principles

- Separation of Concerns & SRP: Isolate responsibilities so each module has one reason to change.
- Modularity & Abstraction: Encapsulate details behind stable interfaces to enable safe swaps and evolution.
- Readability first: Prefer clear naming and straightforward logicâ€”code is read far more than written.

## Object-oriented foundations (SOLID & beyond)

- OCP: Extend behavior without modifying existing code.
- LSP: Subtypes must honor base-type expectations.
- ISP: Use small, focused interfaces; donâ€™t force unused methods.
- DIP: Depend on abstractions, not concrete implementations (enables DI).
- Favor composition over inheritance: Compose behaviors to reduce brittleness.
- Use patterns judiciously: Apply proven patterns (e.g., MVC, Observer, Adapter) as shared vocabulary and solutionsâ€”not cargo cults.
